---
title: "Mosaic plots with `ggplot2`"
author: "Haley Jeppson and Heike Hofmann"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette:
  toc: true
vignette: >
  %\VignetteIndexEntry{Mosaic plots with `ggplot2`}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---


  ```{r setup, echo=FALSE}

knitr::opts_chunk$set(fig.width = 6,
                      fig.height = 4,
                      fig.align='center',
                      dev = "png")

```

```{r echo=FALSE, message=FALSE}
library(ggmosaic)
data(happy, package="productplots")
data(Titanic)
titanic <- as.data.frame(Titanic)
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
  library(grid)

  # Make a list from the ... arguments and plotlist
  plots <- c(list(...), plotlist)

  numPlots = length(plots)

  # If layout is NULL, then use 'cols' to determine layout
  if (is.null(layout)) {
    # Make the panel
    # ncol: Number of columns of plots
    # nrow: Number of rows needed, calculated from # of cols
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
                     ncol = cols, nrow = ceiling(numPlots/cols))
  }

  if (numPlots==1) {
    print(plots[[1]])

  } else {
    # Set up the page
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))

    # Make each plot, in the correct location
    for (i in 1:numPlots) {
      # Get the i,j matrix positions of the regions that contain this subplot
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))

      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
                                      layout.pos.col = matchidx$col))
    }
  }
}

```

# Introduction

### Basic Explanation of `ggmosaic`  
  
`ggmosiac` was designed to create visualizations of categorical data, and has the capability to produce bar charts, stacked bar charts, mosaic plots, and double decker plots. The main focus of this vignette, however, will be on mosaic plots. A mosaic plot is a convenient graphical summary of the conditional distributions in a contingency table, and in a mosaic plot, the area of each graphical element is proportional to the underlying probability of that category. This allows us to easily visualize how the joint distribution is composed of the product of the conditional and marginal distributions -- which, in turn, allows us to see any association that may be occurring between the variables. Because the plot is constructed hierarchically, the ordering of the variables is very important.  


### Types of partitioning

There are two main ways to partition the area - into bars or into spines. When the area is partitioned into bars,the height is proportional to value and the width equally divides the space. Bars can be arranged horizontally (“hbar”) or vertically (“vbar”). Alternatively, the space can be partitioned into spines, where the width is proportional to value, height occupies full range. Spines are space filling and can be arranged horizontally (“hspine”) or vertically (“vspine”).

```{r partitions-a, message=FALSE, fig.width = 7, fig.height = 3.5}

a <- ggplot(data = happy) +
   geom_mosaic(aes(weight = wtssall,  x = product(marital), fill=marital), divider="hbar") +
   theme(axis.text.x=element_text(angle=35, hjust= 1), legend.position="none")+labs(x=" ", title="hbar")


b <- ggplot(data = happy) +
   geom_mosaic(aes(weight = wtssall,  x = product(marital), fill=marital), divider="hspine") +
   theme(axis.text.x=element_text(angle=35, hjust= 1), legend.position="none") + labs(x=" ", title="hspine")

multiplot(a, b, layout=matrix(c(1:2), nrow=1))

```

```{r partitions-b, message=FALSE, fig.width = 7, fig.height = 3.5}

c <- ggplot(data = happy) +
   geom_mosaic(aes(weight = wtssall,  x = product(marital), fill=marital), divider="vbar") +
   theme(legend.position="none") +
   labs(y=" ", x="", title="vbar")
 
d <- ggplot(data = happy) +
   geom_mosaic(aes(weight = wtssall,  x = product(marital), fill=marital), divider="vspine") +
   theme(legend.position="none") +
   labs(y=" ", x="", title="vspine")
 
multiplot(c, d, layout=matrix(c(1:2), nrow=1))
```

##### Paritioning with more than one variable

When more than one variable is to be considered, a type of partition needs to be selected for each variable. By selecting `divider = mosaic()`, the default, or `divider = ddecker()`, the correct number of partitions will be selected. For example, if three variables were to be plotted, the default, `divider = mosaic()`, would partition the plot with spines in alternating directions, beginning with a horizontal spine, i.e. `divider = c("hspine", "vspine", "hspine")`. It is also an option to manually select the type of partition that will be used for each variable, i.e. `divider = c("hbar", "vspine", "hspine")`. It should be noted that the first partition in the vector will be the last partition made in the plot.  

As mentioned above, when no divider is declared, the default `divider = mosaic()` will begin with a horizontal spine and alternate directions with each subsequent variable.

```{r mosaics-1, message=FALSE}

ggplot(data = happy) +
  geom_mosaic(aes(weight = wtssall,  x = product(health, happy, sex), fill=health), na.rm = TRUE) +
   theme(axis.text.x=element_text(angle=25, hjust= 1))+labs(x=" Sex : Health", y = "Happiness", title="divider = mosaic()")

```

Alternatively, a mosaic plot can be created with alternating spines beginning with a vertical spine by declaring `divider = mosaic("v")`.

```{r mosaics-2, message=FALSE}
ggplot(data = happy) +
  geom_mosaic(aes(weight = wtssall,  x = product(health, happy, sex), fill=health), divider = mosaic("v"), na.rm = TRUE) +
   theme(axis.text.x=element_text(angle=10, hjust= .8))+labs(x=" Happiness : Health", y = "Sex", title='divider = mosaic("v")')
 
```
 
A double decker plot will select $n-1$ horizontal spines and end with a vertical spine.

```{r ddecker, message=FALSE}
ggplot(data = happy) +
  geom_mosaic(aes(weight = wtssall,  x = product(health, happy, sex), fill=health), divider = ddecker(), na.rm = TRUE) +
   theme(axis.text.x=element_text(angle=30, hjust= .8))+labs(x=" Happiness : Sex", y = "Health", title='divider = ddecker()')
 
```
 
 




### Hierarchical construction 
 
Because a mosaic plot is constructed hierarchically through alternating spines, the ordering of the variables is very important. To demonstrate the capabilities of `ggmosaic` and to emphasize the importance of the ordering of variables, the following example begins with displaying one variable and is gradually built up to display multiple variables. 

<!-- **Explain the statistical formula** $f(x1, x2, x3) = f(x1 | x2, x3) f(x2, x3) $ -->
 
###### One variable

To begin, to plot is divided into horizontal spines - each representing the proportion of respondents that were a particular level of happy. This plot is useful for answering questions such as, "what proportion of the respondents were very happy?" 

```{r happy-1, message=FALSE}

ggplot(data = happy) +
  geom_mosaic(aes(weight = wtssall,  x = product(happy), fill = happy))+
   theme(axis.text.x=element_text(angle=0, hjust= .5))+labs(x="Happiness", title=" f(happy) ")

```

 
###### Two variables 

This example took the first plot in which the plot was divided into horizontal spines representing the different levels of happiness of the respondents and then split each spine into vertical spines representing the different responses for health. This plot can be used to answer questions such as "what proportion of those not too happy were of excellent health?"


```{r happy-2, message=FALSE}
ggplot(data = happy) +
  geom_mosaic(aes(weight = wtssall,  x = product(happy), fill=health)) +
   theme(axis.text.x=element_text(angle=0, hjust= .5))+labs(x="Happiness", y="Health",  title=" f(health, happy) = f(health|happy) f(happy) ")

```

  
###### Three variables 
  
This example took the second plot and then split each component into horizontal spines representing the different responses for sex. This plot can be used to answer questions such as "what proportion of those not too happy and of excellent health are female?"

```{r happy-3, message=FALSE}
ggplot(data = happy) +
  geom_mosaic(aes(weight = wtssall,  x = product(health, happy), fill=sex)) +
   theme(axis.text.x=element_text(angle=30, hjust= .8))+labs(x="Happiness : Sex", y="Health",  title=" f(sex, health, happy) = f(sex|health, happy) f(health, happy) ")
```


### Importance of ordering

The order in which the variables are listed in the formula can have a large effect the graph.

```{r happy-order, message=FALSE, fig.width = 7.5, fig.height = 3.5}
o1 <- ggplot(data = happy) +
  geom_mosaic(aes(weight = wtssall,  x = product(sex), y=product(degree), fill=degree)) +
  theme(axis.text.x=element_text(angle=0, vjust= -.5), plot.title = element_text(size = rel(1))) + 
  labs(x="Sex", y="Degree",  title=" f(degree, sex) = f(degree|sex) f(sex) ")

o2 <- ggplot(data = happy) +
  geom_mosaic(aes(weight = wtssall,  x = product(degree), y=product(sex), fill=sex)) +
  theme(axis.text.x=element_text(angle=0, vjust= -.50), plot.title = element_text(size = rel(1))) + 
  labs(x="Degree", y="Sex",  title=" f(sex, degree) = f(sex|degree) f(degree) ")

multiplot(o1, o2, layout=matrix(c(1:2), nrow=1, byrow=FALSE))

```


### Conditioning

Another feature of `ggmosaic` is the option to condition on a variable. The conditioning variables can be called in a manner similar to the other variables, but instead of calling ` x = product(x1, x2) `, you declare ` conds = product(x1, x2) `.


```{r conditioning, message=FALSE, fig.width = 7.58, fig.height = 3.5}

c1 <- ggplot(data = happy) +
  geom_mosaic(aes(weight = wtssall,  x = product(happy), conds= degree, fill = happy) ) +  theme(axis.text.x=element_text(angle=25, hjust= 1))+labs(x="Degree", y="Happiness",  title="  f(happy| degree) ")

c2 <- ggplot(data = happy) +
  geom_mosaic(aes(weight = wtssall,  x = product(happy), conds= degree, fill = degree) ) +  theme(axis.text.x=element_text(angle=25, hjust= 1))+labs(x="Degree", y="Happiness",  title="  f(happy| degree) ")

multiplot(c1, c2, layout=matrix(c(1:2), nrow=1, byrow=FALSE))

```

An option to consider when conditioning is to instead use faceting. Faceting provides better labeling than `ggmosaic` currently can. 

```{r conditioning-facet-1, message=FALSE, fig.width = 7.5}

ggplot(data = happy) +
  geom_mosaic(aes(weight = wtssall,  x = product(happy), conds= degree, fill = happy) ) +  theme(axis.text.x=element_text(hjust= .5))+labs(x="Degree", y="Happiness",  title="  f(happy| degree) ")

```

```{r conditioning-facet-2, message=FALSE, fig.width = 7.5}

ggplot(data = happy) +
  geom_mosaic(aes(weight = wtssall,  x = product(happy), fill = happy), divider=mosaic("v") )+labs(x="Degree", y="Happiness",  title="  f(happy| degree) ") + facet_grid(.~degree)
  
```

### Other parameters that can be set:

When there is a variable with many categories, it may be of interest to decrease the size of the spacing between the spines. This can be achieved by declaring `offset = `. The default setting is `offset = 0.01`. 


```{r offset-1, message=FALSE, fig.width=7.5}

ggplot(data = happy) +
  geom_mosaic(aes(weight = wtssall,  x = product(age), fill=marital), na.rm = TRUE) +
  theme(axis.text.x=element_text(angle=0, hjust= .5))+labs(x="Age", y=" ",  title=" f(marital, age | sex)") + facet_grid(sex~.) 
```

```{r offset-2, message=FALSE, fig.width= 7.5}

ggplot(data = happy) +
  geom_mosaic(aes(weight = wtssall,  x = product(age), fill=marital), na.rm = TRUE, offset=0) +
  theme(axis.text.x=element_text(angle=0, hjust= .5))+labs(x="Age", y=" ",  title=" f(marital, age | sex)") + facet_grid(sex~.) 

```




### Other
