---
title: "ggmosaic"
output: html_notebook
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = FALSE, message=FALSE)
```

```{r}
library(ggmosaic)
library(ggplot2)
library(plotly)
library(viridis)
library(gridExtra)
library(NHANES)
library(forcats)
gend <- read.csv("gend.csv")
```

```{r}

```

## Visualizing Categorical Data

Visualizing multidimensional data can be cumbersome. In addition, graphical methods for categorical data are not well developed in comparison with what is available for numeric variables. There is a subtle complexity that arises from the hierarchical structure of the counts and proportions that is important for understanding the multivariate discrete distributions. 

In fact, there are three types of distributions — the joint, the marginal, or the conditional — that we may be interested in examining -- and each supports different kinds of questions about our data. Mosaic plots provide one possibility of visualizing multidimensional data and they can be a powerful and easy option.

Mosaic plots do show up occasionally in the News. The following stacked bar plot and mosaic plot were recently published by The New York Times (October 2016). The data displayed in these plots came from North Carolia. North Carolia releses detailied, individual-level information on every voter in the state. The Upshot combined their poll data with the North Carolina data and then estimated how every voter in the state of North Carolina is likely to vote. 

These plots provide an excellent example of how, with a mosaic plot, you can present two categorical counts simultaneously, and it provides the audience with a clearer view of the underlying data. For example, from the stacked bar chart we can immediately see that Clinton had a significant lead among early voters - but maybe what is more relevent is not just how Clinton led among early voters, but what proportion of North Carolia voters had already voted. The mosaic plot provides a better representation of the voters by having the height of the bins be proportional to the number of voters within that likelihood category.


```{r fig.height=2}
library(png)
library(grid)
img1 <- readPNG("nyt1.png")
grid.raster(img1)
```

```{r fig.height=2}
library(png)
img2 <- readPNG("nyt2.png")
grid.raster(img2)
```
(http://www.nytimes.com/interactive/2016/10/25/upshot/north-carolina-poll.html)


## Introduction to Mosaic Plots 

Mosaic plots are designed to create visualizations of categorical data. The key idea of mosaic plots is that we can map the proportions of a distribution to the areas of a graphic by creating a disjoint partitioning of a rectangular area. 
It is constructed by dividing a square into smaller rectangles recursively, into horizontal and vertical directions in turns. With that said, mosaic plots are a type of parts of a whole plot similar to pie charts. Within a mosaic plot, each rectangular sub-area expands horizontally or vertically according to its weight relative to its siblings. In adition, because the plots are constructed hierarchically, the ordering of the variables is very important.

## Example

```{r}
b1 <- ggplot(diamonds) + geom_rect(aes(xmin=0, xmax=1, ymin=0, ymax=1))+ labs(x="", title='All diamonds') + theme(axis.text = element_text(size=rel(.8)), plot.title= element_text(size=rel(.9)),  axis.text.x = element_text(angle=90, color="white"))+scale_x_product(breaks=1, labels="Very Good")

b2 <- ggplot(diamonds) + geom_mosaic(aes(x = product(cut), fill=cut)) +   labs(x="Cut", title='Diamonds by cut') + 
  guides(fill=guide_legend( reverse = TRUE)) + 
  theme(axis.text = element_text(size=rel(.8)), plot.title= element_text(size=rel(.9)), axis.text.x = element_text(angle=90), axis.title = element_text(size=rel(.85)) )+ scale_x_product(labels=levels(diamonds$cut))

b3 <- ggplot(diamonds) +
  geom_mosaic(aes(x = product(clarity, cut), fill=cut:clarity), offset=0, color="white", size=1) +
  labs(x="Cut ", y="Clarity", title='Diamonds by clarity and cut') + 
  guides(fill=guide_legend( reverse = TRUE)) + 
  theme(legend.position = "none", axis.text = element_blank(), plot.title= element_text(size=rel(.9)), axis.title = element_text(size=rel(.85) ))

#breaks<-((ggplot_build(b3)$data[[1]][1:8,]$ymax-ggplot_build(b3)$data[[1]][1:8,]$ymin)/2) + ggplot_build(b3)$data[[1]][1:8,]$ymin

#b3 <- b3 + scale_x_product(labels=levels(diamonds$cut))+ scale_y_product(breaks=breaks, labels=levels(diamonds$clarity))

grid.arrange(b1, b2, b3, ncol=3)
```

With this example, we see how we begin with the entire dataset - in this case diamonds - represented by a 1x1 square.

We can then look at the distribution of the diamonds according to the cut. In the second plot, the widths of the bins represents the proportion of the diamonds that are of that category of cut. 

Then, within each cut category, we can look at the distribution of clarity. So our final product gives us an idea of the frequency with which each cut and clarity category occur.




## Creation of `ggmosaic`

While mosaic plots have been implemented in a variety of packages, the ordinary grammar of graphics does not support mosaic plots. However, with version 2.0.0 of `ggplot2`, a way for other R packages to implement custom geoms was introduced. With the R package ggmosaic, a custom ggplot2 geom designed for mosaic plots is implemented.

`ggmosaic` was created primarily using `ggproto` and the `productplots` package
 which was created by Hadley and Heike. They refered to their framework product plots, alluding to the computation of area as a product of height and width, and the statistical concept of generating a joint distribution from the product of conditional and marginal distributions. 
 
To begin, `ggmosaic` began as a geom extension of the `rect` geom with the data handling provided in the `productplots` package which calculates xmin, xmax, ymin, and ymax for the `rect` geom to plot.


## ggmosaic limitations

ggplot2 is not capable of handling a variable number of variables

- __current solution:__ read in the variables x1 and x2 as x = product(x1, x2)

```{r vars, eval=FALSE, echo=TRUE, tidy=TRUE, fig.align='center'}

ggplot(data = data) +
  geom_mosaic(aes(### <b> 
  x=product(x1, x2))  ### </b>

```

- `product` function:
    - creates a data frame that combines all of the variables listed 
    - allows for it to pass `check_aesthetics` 
    - then splits the variables back apart for the calculations

The product function creates limitiations for values the variables can take, and what the labels of variables can be. When the variables are combined, the values, variable name, and level are separated using ":", "-", and "."

  - level-variable:value.level-variable:value
  
If any of the variable names or values of the variable contain one of those 3 symbols, the function will break


## geom_mosaic: setting the aesthetics

Aesthetics that can be set:

- __weight__ : select a weighting variable
- __x__ : select variables to add to formula
    - declared as __x__ = product(x1, x2, ...)
- __fill__ : select a variable to be filled 
    - if the variable is not also called in __x__, it will be added to the formula in the first position
- __conds__ : select a variable to condition on

The aesthetics set up the formula that determines the how the joint distribution will be broken down.

These values are then sent through `productplots` functions to create the formula for the desired distribution

  
 __Formula:__ **weight ~ fill + x | conds **
  

As, a side note, when we look at a stacked bar chart the distribution we see is the Y variable conditioned on the X variable.


But first, why would we even be interested in mosaic plots?

## Why Mosaic Plots?


- For a plot to be effective, we must be able to interpret the values, compare them, and see relationships among them with ease, clarity, and accuracy.

Beginning with Cleveland, a substantial amount of prior research has investigated how visual variables such as position, length, area, shape, and color impact the effectiveness of data visualizations

```{r fig.height=5.5,echo=FALSE}
library(jpeg)
clev <- readJPEG("cleve.jpeg")
grid.raster(clev)
```

Mosaic plots excel at depicting part-to-whole relationships. They work by combing these simple, low dimensional graphical primitives in order to display complex, high-dimensional data. 

Additionally, from a whole dataset, there tend to be many dimensions across which to split the data into parts.

While the visual comparisons within mosaic plots (area to area) are not as robust as those within bar charts (length along a common baseline),

Mosaic plots can still be useful in situations where
- space is limited
- or as a starting view of multidimensional part-to-whole data sets

```{r ex, fig.width = 8, fig.height = 4, fig.align='center'}
set.separators(c(":", ";","|")) 
gend$Major_category <- fct_infreq(gend$Major_category)

e1 <- ggplot(gend) +   geom_mosaic(aes(x=product(Major_category), fill = Major_category)) +  scale_fill_viridis(discrete=TRUE, option="D") +labs(x="")+theme(legend.position = "none", axis.text.x = element_text(size=rel(.9), angle=90))

e2 <- ggplot(gend) +   geom_mosaic(aes(x=product(gender), weight=number, fill = gender, conds=product(Major_category)), na.rm=TRUE) + scale_fill_viridis(discrete=TRUE, option="D", begin=.2, end=.9)+labs(x="")+scale_x_product(labels= levels(gend$Major_category))+theme(legend.position = "none", axis.text.x = element_text(size=rel(.9), angle=90))

e3 <- ggplot(gend) +   geom_mosaic(aes(x=product(Major_category), weight=number, fill = gender), na.rm=TRUE) +  scale_fill_viridis(discrete=TRUE, option="D", begin=.2, end=.9) +labs(x="")+scale_x_product(labels= levels(gend$Major_category))+theme(legend.position = "none",axis.text.x = element_text(size=rel(.9), angle=90))

grid.arrange(e1, e2, e3, top = "f(Major Category) × f(sex | Major Category) = f(sex, Major Category)", ncol=3)

```

With this example, we can see how a mosaic plot is composed of the product of the marginal distribution of major category and the distribution of sex conditioned on major category.
The result is that each one of the disjoint segments of the rightmost mosaic plot has area proportional to the corresponding joint probability:
Additionally, in a mosaic plot, the marginals can be quickly estimated by looking at a single row or color. In contrast, these same data would require ten bars on a bar chart, and one would need to locate and mentally “stack” bars together to make the same comparisons.

If the goal is to gain insight faster, with all of the information displayed in one plot, Mosaic plots can provide a good starting point.


## GeomMosaic

- Easy customization
- Facetting
- Ease of Use 
- Versatile

The ggmosaic package is not limited to mosaic plots. Rather, it is capable of producing a wide variety of plots, including  bar charts, stacked bar charts, spine plots, mosaic plots, and double decker plots

## Translating GeomMosaic for ggplotly()

**Having a geom designed for mosaic plots does more than allow us to use the ggplot2 customization options, it allows us to go even further: it allows for a `ggplotly()` hook **

Disclaimer: This information came from Carson Sievert, the maintainer and lead developer of plotly's R package.

Although the `ggplotly()` function translates most of the geoms bundled with the `ggplot2` package, it has no way of knowing about the rendering rules for custom geoms. 

The `plotly` package does, however, contain the infrastructure to 
provide translations of custom geoms to plotly.

In `ggplot2`, many geoms are special cases of other geoms. For example,`geom_line()`is equivalent to `geom_path()` once the data is sorted by the x variable. 


Because GeomMosaic can be reduced to the lower-level geom GeomRect, with the assistance of Carson, we were able to write a method for the `to_basic()` generic function in `plotly`.


## Interactive Mosaic Plots


`ggplotly()`: the ggplotly function, 

- converts the mosaic plot into an interactive, web-based version! 

- allows us to move past the less than satisfactory labeling that 
can occur with mosaic plots since space is a limiting factor. 

- aids exploration and helps to provide details for faster insights

For example, in this plot the tooltip hoover gives us the combination of variable values that each rectangle represents - Additionally, it tells us the frequency with which the cobination is present in the data set. 

The plotly mosaic plot has the fuctionality of other plotly graphs - for instance you can turn on off segments according to the fill.

```{r plotly}
e3<- e3+theme(legend.position="right", axis.text.x = element_text(size=rel(.9), angle=90))+
    guides(fill=guide_legend(title="Gender", reverse = TRUE)) 
ggplotly(e3)
```

So now I will go through some examples that represent the versatility of the ggmosaic package.

## Examples

In this first example, I've taken the NHANES data and broken it up to display the different kinds of households that were surveryed. 

We can see the Marginal distribution of Marital status represented by the widths of the bars

We can see the margianal distribution of number of kids according to the relative areas of each color

and we can see the joint distribution of the two variables. 

```{r}
NHANES$nBabies <- factor(NHANES$nBabies)
NHANES$MaritalStatus <- relevel(NHANES$MaritalStatus, "Separated")
NHANES$MaritalStatus <- relevel(NHANES$MaritalStatus, "Married")
NHANES$MaritalStatus <- relevel(NHANES$MaritalStatus, "LivePartner")
NHANES$MaritalStatus <- relevel(NHANES$MaritalStatus, "NeverMarried")
baby <- ggplot(NHANES) +  geom_mosaic(aes(x=product(MaritalStatus), fill = nBabies), divider=ddecker(), offset=0.005, na.rm=TRUE) + scale_fill_viridis(discrete=TRUE) +labs(x="Marital Status") + scale_x_product(labels=c(levels(NHANES$MaritalStatus), "NA")) + guides(fill=guide_legend(title = "# kids", reverse = TRUE))+theme(axis.text.x = element_text(angle=90))

baby

```

## 

For this next example, I took a plot from FlowingData that looked at how many drink a person has on average when they drink. 

In this example, there was an a bar chart for the number of drinks and you could toggle between different races and genders to see how they compare. 

I thought it would be nteresting to see what this data would look like as a mosaic plot so we could potentially get a better sence of how the different levels of gender and race relate.

```{r}
drinks <- readPNG("drinks.png")
grid.raster(drinks)
```


## 

So here is an example of this data represented as a mosaic plot rather than as 10 different bard charts. 

We can still see each of the ar charts if we look at the vertical bars

But we also able to get an idea of how the different combinations of gender and race relate.

```{r examples}

NHANES$AlcoholDay <- as.factor(NHANES$AlcoholDay)
levels(NHANES$AlcoholDay) <- c("1",  "2",  "3",  "4",  "5",  "6",  "7",  "8",  "9", rep("10 or more", 16))

NHANES$Race1 <- fct_infreq(NHANES$Race1)

dr <- ggplot(NHANES) +   geom_mosaic(aes(x=product(Gender, AlcoholDay, Race1), fill = AlcoholDay:Gender),  offset=0.005, na.rm=TRUE)+   scale_fill_viridis(discrete=TRUE, option="B", begin=.2, end=.9, direction=-1) + labs(x="Race", title="When you drink, how many drinks do you consume on average?",  subtitle="Here is how different groups responded to surveys taken '09-'14.")

## http://flowingdata.com/2016/07/11/how-much-alcohol-americans-drink/

labels <- levels(NHANES$Race1:NHANES$Gender)

dr <- dr  +  scale_x_product("Race:Gender", labels=labels) +
  theme(
    panel.background = element_rect(fill="white"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_blank(),
    axis.text.y  = element_blank(), 
    axis.text.x  = element_text(size=rel(1), angle=90, vjust=0.5)
  )+ guides(fill=guide_legend(reverse = TRUE))

ggplotly(dr)

```



## Double decker plot

This example is a modification of a mosaic plot where instead of alternating hspines and vspines, a doble decker is composed of n−1 hspines and ends with a vspine

So in the plot we've first split by stem major category, and then by gender. 

Each combination of stem major category and gender is then represented as a vertical bar where the width represents the proportion of that category.

Then lastly, each bar is broken into median income decile.

The finished product, is admitedly busy, but is a clean way to present the three variables and to show how the proportions differ.

```{r}

inc <- ggplot(gend) + 
    geom_mosaic(aes(x=product(gender, Major_category), fill=Median_income, weight=number), divider=ddecker(), offset=0.005, na.rm=TRUE) + 
    scale_fill_viridis(discrete=TRUE)+ 
    labs(x="Gender by Major Category", title="Deciles of median income by gender by major") +
    guides(fill=guide_legend(title="Median Income", reverse = TRUE)) + scale_x_product(labels=levels(gend$Major_category:gend$gender))+theme(axis.text = element_text(size=rel(.9)), axis.text.x = element_text(angle=90))

ggplotly(inc)


```

##
Now, as the prodplots paper written by Hadley and Heike about the product plot package declares:

The product plots framework defines a **large** space of potential plots 

In all of these plots, the area is proportional to probability, and each represents the same joint distribution. 

WHile most of these plots should probably never actaully see the light of day, I wanted to take a moment to highlight the incredible versatility that ggmosaic (via productplots) is capable of.
 
```{r vers}

w1 <- ggplot(gend) + geom_mosaic(aes(x=product(gender, Major_category), fill=Median_income, weight=number), divider=c("vspine", "vbar", "hspine"), offset=0.00, na.rm=TRUE) + scale_fill_viridis(discrete=TRUE)+
  guides(fill=guide_legend( reverse = TRUE))  +labs(x="", y="")+
  theme(
    plot.title = element_blank(),
    axis.text = element_blank(),
    legend.position = "none",
    legend.title=element_blank()
    
  )


w2 <- ggplot(gend) + geom_mosaic(aes(x=product(gender, Major_category), fill=Median_income, weight=number), divider=c("vspine", "vbar", "vbar"), offset=0.05, na.rm=TRUE) + scale_fill_viridis(discrete=TRUE) +guides(fill=guide_legend( reverse = TRUE)) + coord_flip() +labs(x="", y="")+ theme(
    plot.title = element_blank(),
    axis.text = element_blank(),
    legend.position = "none",
    legend.title=element_blank()
    
  )


w8<- ggplot(gend) + geom_mosaic(aes(x=product(gender, Major_category), fill=Median_income, weight=number),  divider=c("vbar", "hspine", "vspine"), offset=0.01, na.rm=TRUE) + scale_fill_viridis(discrete=TRUE)+ 
  guides(fill=guide_legend( reverse = TRUE)) + coord_flip() +labs(x="", y="")+
  theme(
    plot.title = element_blank(),
    axis.text = element_blank(),
    legend.position = "none",
    legend.title=element_blank()
    
  )


w4 <- ggplot(gend) + 
  geom_mosaic(aes(x=product(gender, Major_category), fill=Median_income, weight=number), divider=c("hbar", "hspine", "vspine"), offset=0.001, na.rm=TRUE) + 
  scale_fill_viridis(discrete=TRUE)+ guides(fill=guide_legend( reverse = TRUE))  +labs(x="", y="")+
  theme(
    plot.title = element_blank(),
    axis.text = element_blank(),
    legend.position = "none",
    legend.title=element_blank()
  )


w5 <- ggplot(gend) + geom_mosaic(aes(x=product(gender, Major_category), fill=Median_income, weight=number), offset=0.015, na.rm=TRUE) +
  scale_fill_viridis(discrete=TRUE)+ 
  guides(fill=guide_legend( reverse = TRUE))  +labs(x="", y="")+
  theme(
    plot.title = element_blank(),
    axis.text = element_blank(),
    legend.position = "none",
    legend.title=element_blank()
  )
  

w6 <-ggplot(gend) + 
  geom_mosaic(aes(x=product(gender, Major_category), fill=Median_income, weight=number), 
              divider=ddecker(), offset=0.005, na.rm=TRUE) + 
  scale_fill_viridis(discrete=TRUE)+
  guides(fill=guide_legend( reverse = TRUE)) +labs(x="", y="")+
  theme(plot.title = element_blank(),
    axis.text = element_blank(),
    legend.position = "none",
    legend.title=element_blank()
  )

w7 <- ggplot(gend) + 
  geom_mosaic(aes(x=product(gender, Major_category), fill=Median_income, weight=number),  divider=c("vspine", "vspine", "vspine"), offset=0.0001, na.rm=TRUE) + 
  scale_fill_viridis(discrete=TRUE)+ 
  guides(fill=guide_legend( reverse = TRUE))  +labs(x="", y="")+
  theme(
    plot.title = element_blank(),
    axis.text = element_blank(),
    legend.position = "none",
    legend.title=element_blank()
  )

w3 <-  ggplot(gend) + 
  geom_mosaic(aes(x=product(gender, Major_category), fill=Median_income, weight=number),  divider=mosaic("v"), offset=0.01, na.rm=TRUE) + 
  scale_fill_viridis(discrete=TRUE)+ 
  guides(fill=guide_legend( reverse = TRUE))  +labs(x="", y="")+
  theme(
    plot.title = element_blank(),
    axis.text = element_blank(),
    legend.position = "none",
    legend.title=element_blank()
  )

w9 <- ggplot(gend) + 
  geom_mosaic(aes(x=product(gender, Major_category), fill=Median_income, weight=number),  divider=c("hspine", "hspine", "hspine"), offset=0.0001, na.rm=TRUE) + 
  scale_fill_viridis(discrete=TRUE)+ 
  guides(fill=guide_legend( reverse = TRUE))  +labs(x="", y="")+
  theme(
    plot.title = element_blank(),
    axis.text = element_blank(),
    legend.position = "none",
    legend.title=element_blank()
  )

grid.arrange(w1, w2, w3, w4, w5, w6, w7, w8, w9, ncol=3)

```

## Shiny 

Taking another quote from the prodplots paper:

The product plots package, lays the framework for much future work, particularly because the framework leads to a combinatorial explosion of possibilities. 

With a shiny app, we can access the many ways a population can be broken into segments by easily playing with adding differrent variables or by changing the order of the variables. 

```{r}
shiny <- readPNG("shiny.png")
grid.raster(shiny)
```

## Conclusion

People have a natural tendency to compare shapes by area, and we can leverage this tendency to depict statistical distributions via mosaic plots. 


Mosaic plots can be implemented easily with the implementation of `GeomMosaic` into `ggplot2`

While admittedly there are still issues with how ggmosaic is implemented, but with the new version of ggplot2 that was just released, we are hopeful that we will be able to fix a couple of these larger issues in the near future. 